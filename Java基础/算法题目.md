# 算法题

* 有一条长长的阶梯，如果每步跨2阶，那么最后剩1阶；如果每步跨3阶，那么最后剩2阶；如果每步跨5阶，那么最后剩4阶；
如果每步跨6阶，最后剩5阶；只有当每步跨7阶时，最后才正好走完，一阶也不剩。请问这条阶梯至少有多少阶？

```java
public static void main(String[] args) {
    int i = 1;
    boolean flag = true;
    while (flag) {
        if (i % 2 == 1 && i % 3 == 2 && i % 5 == 4 && i % 6 == 5 && i % 7 == 0) {
            System.out.printf("i = %d \n",i);
            flag = false;
        }
        i++;
    }
}
// 输出i = 119 

```

* 平均分配算法（将若干数据平均分配给若干用户）

```java
List<String> dataList = new ArrayList<>();
Stream.iterate(1, i -> i + 1).limit(3).forEach(i -> {
  dataList.add("data_" + i);
});

List<String> userList = new ArrayList<>();
Stream.iterate(1, i -> i + 1).limit(200).forEach(i -> {
  userList.add("user" + i);
});

// 队列最大容量，每个人最多分配5条数据
int allotListHaxCapacity = Math.min(dataList.size(), userList.size() * 5);
// 分配队列
List<String> allotList = new ArrayList<>(allotListHaxCapacity);

// 填充分配
for (int i = 0; i < allotListHaxCapacity; ) {
  for (String s : userList) {
	if (i >= allotListHaxCapacity) {
	  i++;
	  break;
	}
	allotList.add(s);
	i++;
  }
}

Map<String, List<String>> allotMap = new HashMap<>();

// 给用户分配数据
for (int i = 0; i < dataList.size(); i++) {
  if (i >= allotList.size()) {
	break;
  }
  String user = allotList.get(i);
  List<String> data = allotMap.computeIfAbsent(user, k -> new ArrayList<>());
  data.add(dataList.get(i));
}

System.out.println(allotMap);
```

# 100-200之间能被3整除的个数，并以三角形输出

```java
Supplier<Stream<Integer>> supplier = () -> Stream.iterate(100, i -> i + 1)
                .limit(101)
                .filter(i -> i % 3 == 0);
int count = (int) supplier.get().count();
System.out.println("100-200之间能被3整除的个数：" + count);

List<Integer> list = supplier.get().collect(Collectors.toList());
IntStream.range(0, count).forEach(i -> {
    for (int j = 0; j < i; j++) {
	System.out.print(list.get(i) + " ");
    }
    System.out.println();
});
```
> 输出

```bash
105 
108 108 
111 111 111 
114 114 114 114 
117 117 117 117 117 
120 120 120 120 120 120 
```

# 判断字符对称以及长度

```java

/**
     *  判断括号成对出现
     * @param str
     * @return
     */
    public static boolean judge(String str) {
        if (str == null || str.length() == 0) {
            return false;
        }
        Map<Character, Character> map = new HashMap<>();
        map.put(')', '(');
        map.put(']', '[');
        map.put('}', '{');

        int len = str.length();
        Queue<Character> queue = new LinkedList<>();
        Character elem;
        for (int i = 0; i < len; i++) {
            elem = str.charAt(i);
            if (map.containsValue(elem)) {
                queue.offer(str.charAt(i));
            } else if (map.containsKey(elem)) {
                if (queue.isEmpty()) {
                    return false;
                }
                if (Objects.equals(queue.peek(), map.get(elem))) {
                    queue.poll();
                } else {
                    return false;
                }
            }
        }
        return queue.isEmpty();
    }

    /**
     *  无重复字符的最长子串
     * @param str abacabdcAca
     * @return
     */
    public static int maxCount(String str) {
        if (str == null || str.length() == 0) {
            return 0;
        }
        int len = str.length();
        int maxLength = 0;
        Queue<Character> queue = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            while (queue.contains(str.charAt(i))) {
                queue.poll();
            }
            queue.offer(str.charAt(i));

            if (queue.size() > maxLength) {
                maxLength = queue.size();
            }
        }

        return maxLength;
    }
```
